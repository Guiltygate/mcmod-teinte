


testing




private int[] location;
private HashSet<int[]> moduleLocations;
private Ticket ticket;
private boolean triedToAssignTicket;

public TileEntityMainframeCore(){
location = null;
moduleLocations = new HashSet();
triedToAssignTicket = false;
}

@Override
public void invalidate() {
ForgeChunkManager.releaseTicket(ticket);
super.invalidate();
}

public void forceChunkLoading(Ticket ticket) {
if (this.ticket == null)
	this.ticket = ticket;
ChunkCoordIntPair chunk = new ChunkCoordIntPair(xCoord >> 4, zCoord >> 4);
ForgeChunkManager.forceChunk(ticket,chunk);
}

@Override
public void updateEntity() {
super.updateEntity();
if(!triedToAssignTicket && !worldObj.isRemote){
	triedToAssignTicket = true;
	System.out.println("huehuehue");
	if(ticket==null)
		ticket = ForgeChunkManager.requestTicket(Singularity.instance,worldObj,Type.NORMAL);
	if(ticket==null)
		System.out.println("Ticket could not be reserved for MainframeCore @ ("+xCoord+","+yCoord+","+zCoord+")");
	else {
		ticket.getModData().setInteger("coreX",xCoord);
		ticket.getModData().setInteger("coreY",yCoord);
		ticket.getModData().setInteger("coreZ",zCoord);
		ForgeChunkManager.forceChunk(ticket,new ChunkCoordIntPair(xCoord>>4,zCoord>>4));
	}
}
}













Weight : Symbol

10 - YP
50 - YN
200 - ZN

< 10 = YP
< 60 = YN
< 260 = ZN

YP -> YP-XN-[XP/ZP]



/**
class GrowthPattern{
	
	private int[] tiers = new int[]{ 4 ,17};
	private int currentTier = 0;
	private GrowthDirection gd;
	
	

	
	public BlockPos getNextBlockPos( BlockPos pos ,int distance) {
		int tier = -1;
		for( int i=0; i < tiers.length; i++) {
			if( distance < tiers[i]) {
				tier = i;
				break;
			}
		}
		
		switch( tier) {
		case 0: return tierZero( pos);
		case 1: return tierOne( pos);
		case 2: return tierTwo( pos);
		case 3: return tierThree( pos);
		case 4: return tierFour( pos);
		}
		
		return Direction.NULL.pos;
	}
	
	private BlockPos tierZero( BlockPos pos) {
		Direction[] choices = new Direction[] { Direction.YP ,Direction.XP ,Direction.XN ,Direction.ZP ,Direction.ZN};
		int[] weights = new int[] { 3 ,1 ,1 ,1 ,1};
		Direction shifter = pickRandom( choices);
		
		if( this.gd == null) {
			Direction directionConst = pickRandom( choices);
			Direction tierConst = Direction.YP;
			this.gd = new GrowthDirection( tierConst ,directionConst ,shifter);
		}else {
			this.gd.update( shifter);
		}
		
		return pos.add( this.gd.pickDirection().pos);
	}
	
	
	private BlockPos tierOne( BlockPos pos) {
		return Direction.NULL.pos;
	}
	
	private BlockPos tierTwo( BlockPos pos) {
		return Direction.NULL.pos;
	}
	
	private BlockPos tierThree( BlockPos pos) {
		return Direction.NULL.pos;
	}
	
	private BlockPos tierFour( BlockPos pos) {
		return Direction.NULL.pos;
	}
	
	private Direction pickRandom( Direction[] choices) {
		return choices[ new Random().nextInt( choices.length)];
	}
	
}





class GrowthDirection{
	
	public Direction tierConst;
	public Direction directionConst;
	public Direction shifter;
	
	public GrowthDirection( Direction tier ,Direction direction ,Direction shifter) {
		this.tierConst = tier;
		this.directionConst = direction;
		this.shifter = shifter;
	}
	
	
	public void update( Direction shifter) {
		this.shifter = shifter;
	}
	
	
	public Direction pickDirection() {
		int bound = 3;
		int randInt = new Random().nextInt( bound);
		switch( randInt) {
		case 0: return this.tierConst;
		case 1: return this.directionConst;
		case 2: return this.shifter;
		}
		return tierConst;
	}
	
}


**/





